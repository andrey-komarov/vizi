<html>
    <head>
        <title>
            Сортировка кучей. Теория
        </title>
        <style type = "text/css">
            font.stn {
                font-family: "Times New Roman Cyr", "Times New Roman", "Times New", serif; 
                background-color: transparent; 
            }
            font.symbol {
                font-family: "Symbol"; 
                font-size: 10pt;
                background-color: transparent; 
            }
            font.code {
                font-family: "Lucida Console"; 
                font-size: 11pt;
                background-color: transparent; 
            }
        </style>
    </head>
    <body><font class="stn">
      <B>Сортировка кучей. Теория</B>
      <OL>
         <LI><B>Кучи</B>
         <P><B>Двоичной кучей</B> (binary heap) называют массив с определённыи свойствами упорядоченности.Чтоы формулировать эти свойства, будем рассматривать массив как двоичное дерево(см <A HREF="HeapSort_ru.html">визуализатор</A>). Каждая вершина дерева соответствует элементу массива. Есливершина имеет индекс i, то её родитель еет индекс roundDown[i/2] (вершина с индеком 1 является корнем), а её дети - индексы 2i и 2i + 1. Будем считать, что куча может не занимать всего массива, и поэтому будем хранить не только массив A и его длину length[A], но также специаный параметр - heap-size[A] (размер кучи), причём heap-size[A] &lt;= length[A]. Куча состоит из элементов A[1], ..., A[heap-size[A]]. Движение по дереву осуществяется процедурами:
         <P><font class="code">Parent(i)
         <OL>
            <LI><B>return</B> roundDown[<I>i</I>/2]
         </OL>
         <P>Left(i)
         <OL>
            <LI><B>return</B> 2<I>i</I>
         </OL>
         <P>Right(i)
         <OL>
            <LI><B>return</B> 2<I>i</I> + 1
         </OL></font>
         <P>Элемент A[1] является корнем дерева.
         <P>В большинстве компьютеров для выполнения процедур Left и Parent можно использовать команды левого и правого сдвига (Left, Parent); Right требует левого сдвига, после которого в младший разряд помещается единица.
         <P>Элементы, хранящиеся в куче, должны обадать <B>основными свойствами кучи</B> (heap poperty): для каждой вершины i, кроме корня (т.е. при 2 &lt;= i &lt;= heap-size[A]),
         <P><CENTER>A[Parent{i}] &gt;= A[i] (*).</CENTER>
         Отсюда следует, что значение потомка не превосходит значения предка. Таким образом, наибольщий элемент дерева (или любого поддерева) находится в корневой вершине дерева(этого поддерева).
         <P><B>Высотой</B> (height) вершины дерева называется высота поддерева с корнем в этой вершине (число рёбер в самом длинном пути  началом в этой вершине вниз по дереву к листу). Высота дерева, таким образом, совпадает  высотой его корня. В дереве, составляющи кучу, все уровни (кроме, быть может, последнего) заполнены полностью. Поэтому высота этого дерева равна O(logn), где n - число элементов в куче. Как мы увидим ниже, время работы основных операций над кучей пропорцанально высоте дерева и, следовательно, составляет O(logn). Перечилим основыне операции над кучей.
         <P>
         <UL>
            <LI>Процедура Heapify позволяет подерживать основное свойство (*). Время работы составляет O(logn).
            <LI>Процедура Build-Heap строит кучу из исходного (неотсортированного массива). Время работы O(n).
            <LI>Процедура HeapSort ортирует массив, не используя дополлнительной памяти. Время работы O(nlogn).
            <LI>Процедуры Extract-Max (взятие наибольшего) и Insert (добавление элемента) используются при моделировании очереди  приоритетаи на базе кучи(здесь не рассмотрено). Время работы ооих процедур составляет O(logn).
         </UL>
         <LI><B>Сохранение основного свойства кучи</B>
         <P>Процедура  Heapify - важное средство работы с кучей. Её параметрами являются маcсив A и индек i. Предполагается, что поддеревья с корнями Left(i) и Right(i) уже обладают основным свойтсвом. Процедура переставляет элементы поддерева с вершиной i, после чего оно будет основным свойством. Идея проста: если основное свойство не выпоенео для вершины i, то её следует поменять с большим из её детей и т.д., пока элемент A[i] не погрузится до нужного места.
         <P><FONT class="code">Heapify(A, i)
         <OL>
            <LI><I>l</I> &lt;- Left(<I>i</I>)
            <LI><I>r</I> &lt;- Right(<I>i</I>)
            <LI><B>if</B> <I>l</I> &lt;= <I>heap-size</I>[A] и A[<I>l</I>] &gt; A[<I>i</I>]
            <LI>&nbsp;&nbsp;&nbsp;<B>then</B> <I>largest</I> &lt;- <I>l</I>
            <LI>&nbsp;&nbsp;&nbsp;<B>else</B> <I>largest</I> &lt;- <I>i</I>
            <LI><B>if</B> <I>r</I> &lt;= <I>heap-size</I>[A] и A[<I>r</I>] &gt; A[<I>largest</I>]
            <LI>&nbsp;&nbsp;&nbsp;<I>largest</I> &lt;- <I>r</I>
            <LI><B>if</B> <I>largest</I> != <I>i</I>
            <LI>&nbsp;&nbsp;&nbsp;<B>then</B> обменять A[<I>i</I>] &lt;-&gt;A[<I>largest</I>]
            <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Heapify(A, <I>largest</I>)
         </OL></font>
         <P>Работа процедуры Heapify  показана в <A HREF="HeapSort__ru.html">визуализаторе</A>. В строках 3-7 в переменную largest помещается индекс наибольшего из элементов A[i], A[Left(i)] и A[Rigth(i)]. Если largest = i, то элемент A[i] уже "погрузился" до нужного места, и работа процедуры закончена. Иначе процедура меняет местами A[i] и A[largest] (что обеспечивает выполнение свойтсва: A[Parent(i)] &gt;= A[i], в вершине i, но, возможно, наршает это саойство в вершине  largest) и рекурсивно вызывает себя для вершны largest, чтобы иправить возможные нарушения.
         <P>Оценим время работы Heapify. На каждом шаге требуется произвети O(1) действий, не считая рекурсивного вызова. Пусть T(n) - время работы для поддерева, содержащего n элементов. Если поддерево с корнем i состоит из n элементов, то поддеревья с корнями Left(i) и Right(i) содержат не более чем по 2n/3 элеентов каждое(наихудший случай - когда последний уровень в дереве заполнен на половину). Таки образом,
         <P><CENTER>T(n)&lt;=T(2n/3) + O(1).</CENTER>
         <P>Из основной теоремы о рекуррентных оценках поучаем, что T(n) = O(logn). Эту же оценку можно поучить так: на каждом шаге мы спускаемсяпо дереву на один уровень, а высота дерева есть O(logn).
         <LI><B>Построение кучи</B>
         <P>Пусть дан массив A[1..n], который мы хотим превратить в кучу, переставив его элементы. Для этого можно использовать процедуру Heapify , применяя её по очеред ко всем вершина, начиная с нижних. Поскольку вершины с номерами roundDown[n/2] + 1, ... , являются листьями, поддеревья с этими вершинами удовлетворяют основному свойству. Для каждой из оставшихся вершин, в порядке убывания индексов, мы применяем процедуру Heapify. Порядок обработки вершин гарантирует, что каждый раз условия вызова процедуры (выполнение оновного свойства для поддеревьев) будут выполнены.
         <P><font class="code">Build-Heap(A)
         <OL>
            <LI><I>heap-size</I>[A] &lt;- <I>length</I>[A]
            <LI><B>for</B> <I>i</I> &lt;- <I>roundDown[length[A]/2]</I> <B>downto</B> 1
            <LI>&nbsp;&nbsp;&nbsp;<B>do</B> Heapify(A, i)
         </OL></font>
         <P>Работа процедуры Build-Heap продемонтрирована в <A HREF="HeapSort_ru.html">визуализаторе</A>.
         <P>Ясно, что время работы процедуры Build-Heap не превышает O(nlogn). Дейтвтельно, процедура Heapify вызывается O(n) раз, а каждое её выполнение требует времени O(logn). Эту оценку ожно улучшить и поучить, что время работы процедуры Build-Heap составляет O(n), но здесь вывод этого факта ен удет приведён(см. Т.Кормен, Ч.Лейзерсон, Р.Ривест "Алгориты построение и анализ" =)).
         <LI><B>Агоритм сортировки с помощью кучи</B>
         <P>Агоритм сортировки  помощью кучи состоит из двух частей. Сначала вызываетя процедура Build-Heap, после
         выполнения которой массив становится кучей. Идея второй части проста: максимальный элемент массива теперь
         находится в корне дерева (A[1]). Его следует поменять с A[n], уменьшить размер кучи на 1 и восстановить основное свойство в корневой вершине (поскольку поддеревья с корнями Left(1) и RIght(1) не утратили основного свойства кучи, это можно сделат  поощью процедуры Heapify). После этого в корне будет находиться максимальный из оставшихся элементов. Так делается до тех пор, пока в куче не останется всего один элемент.
         <P><font class="code">Heapsort(A)
         <OL>
            <LI>Build-Heap(A)
            <LI><B>for</B> i &lt;- <I>length</I>[A] <B>downto</B> 2
            <LI>&nbsp;&nbsp;<B>do</B>&nbsp;поменять A[1] &lt;-&gt; A[i]
            <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>heap-size</I>[A] &lt;- <I>heap-size</I>[A] - 1
            <LI>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Heapify(A, 1)
         </OL></font>
         <P>Работу данного алгоритма показывает <A HREF="HeapSort_ru.html">визуализатор</A>.
         <P>Время работы процедуры Heapsort составляет O(nlogn). Действительно, первая часть (построение кучи) требует времени O(n), а каждое из n - 1 выполнений цикла for занимает O(logn).
      </OL>
      <HR>
      &copy;&nbsp;Информация для данной теоритисческой спраки полностью взята из книги Т.Кормен, Ч.Лейзерсон, Р.Ривест "Алгориты построение и анализ"
      </font>
    </body>
</html>