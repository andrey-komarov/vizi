<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=WINDOWS-1251">
        <title>Сортировка слиянием - описание алгоритма</title>
        <style type = "text/css">
        body {
            font-family: Times New Roman;
            font-size: 12pt;
        }
        font.symbol {
            font-family: Symbol;
        }
        </style>
    </head>
    <body>
        <div align = "center">
            <h2>Описание алгоритма сортировки слиянием</h2>
        </div>
        <p> Многие алгоритмы по своей природе рекурсивны: решая некоторую задачу, 
            они вызывают самих себя для решения её подзадач. Такова идея метода "разделяй и влавствуй".
            Сначала задача разбивается на несколько подзадач меньшего размера. 
            Затем эти задачи решаются с помощью рекурсивного вызова или непосредственно,
            если их размер достаточно мал. 
            Наконец, их решения комбинируются, и получается решение исходной задачи.
        </p>
        <p>
            Для решения задачи сортировки эти три этапа выглядят так:
        </p>
        <ol>
            <li>Сортируемый массив разбивается на две половины меньшего размера;</li>
            <li>Каждая из получившихся половин сортируется отдельно;</li>
            <li>Два упорядоченных массива половинного размера соединяются в один.</li>
        </ol>
        <p>
            Рекурсивное разбиение задачи на меньшие происходит до тех пор, пока размер массива 
            не достигнет единицы (любой массив длины 1 можно считать упорядоченным).
        </p>
        <p>
            Нетривиальным этапом является соединение двух упорядоченных массивов в один. 
            Основную идею слияния двух отсортированных массивов можно объяснить на следующем примере.
            Пусть мы имеем две стопки карт, лежащих рубашками вниз так, 
            что в любой момент мы видим верхнюю карту в каждой из этих стопок. 
            Пусть также, карты в каждой из этих стопок идут сверху вниз в неубывающем порядке.
            Как сделать из этих стопок одну? На каждом шаге мы берём меньшую из двух верхних карт и кладём её (рубашкой вверх) в результирующую стопку. 
            Когда одна из оставшихся стопок становится пустой, мы добавляем все оставшиеся карты второй стопки к результирующей стопке.
        </p>                           
        <p>
            Далее следует пример процедуры merge, реализующей слияние двух отсортированных подмассивов.
            Параметрами этой процедуры являются массив <i>A</i> и числа <i>l</i>, <i>m</i>, <i>r</i>, 
            указывающие границы сливаемых участков. Процедура предполагает, что 
            <i>l&nbsp;<font class = "symbol">&#163;</font>&nbsp;&nbsp;m&nbsp;<font class = "symbol">&#60;</font>&nbsp;&nbsp;r</i> и что участки 
            <i>A&nbsp;&#91;l&nbsp;..&nbsp;m&#93;</i> и 
            <i>A&nbsp;&#91;m&nbsp;+&nbsp;1&nbsp;..&nbsp;r&#93;</i> 
            уже отсортированы, и сливает их в один участок <i>A&nbsp;&#91;l&nbsp;..r&#93;</i>.
        </p>                                       
<pre>
        merge(A, l, m, r)
   1        for i = l to r do
   2            B[i] = A[i];
   3        p1 = l;
   4        p2 = m + 1;
   5        for k = l to r do
   6            if ((p1 &gt; m) or (p2 &gt; r)) then
   7                if (p1 &gt; m) then
   8                    A[k] = B[p2];
   9                    p2++;
  10                else
  11                    A[k] = B[p1];
  12                    p1++;
  13            else
  14                if (B[p1] &gt; B[p2]) then
  15                    A[k] = B[p2];
  16                    p2++;
  17                else
  18                    A[k] = B[p1];
  19                    p1++;
</pre>
        <p>
            В строках 1 и 2 заполняется массив <i>B</i>. При этом роли "стопок карт" выполняют подмассивы
            <i>B&nbsp;&#91;l&nbsp;..&nbsp;m&#93;</i> и 
            <i>B&nbsp;&#91;m&nbsp;+&nbsp;1&nbsp;..&nbsp;r&#93;</i>. 
            В строках 3 и 4 указатели <i>p1</i> и <i>p2</i> устанавливаются на элементы 
            первого и второго массивов соответственно. Строки 7..12 отвечают за копирование 
            элементов в случае, если одна из сливаемых частей закончилась. В строках 14..19 
            выбирается и копируется наименьший из текущих элементов подмассивов.
        </p>
        <p>
            Алгоритм сортировки слиянием, в отличие от большинства других алгоритмов сортировок, 
            обладает важным свойством, называемым <b>устойчивостью</b>. 
            Именно, если во входном массиве присутствуют несколько равных чисел, то после 
            сортировки они не поменяют своего взаимного расположения. Для сортировки 
            массива чисел устойчивость избыточна. Это свойство бывает необходимо при
            сортировке массива некоторых объектов, содержащих помимо ключа какую-нибудь дополнительную информацию.
            Описанная выше процедура слияния поддерживает это свойство благодаря строгому неравенству в строке 14.
        </p>
        <p>
            При реализованной процедуре слияния, процедура, сортирующая часть массива
            <i>A&nbsp;&#91;l&nbsp;..&nbsp;m&#93;</i>, пишется без особых трудностей:
        </p>
<pre>
        mergeSort(A, l, r)
   1        if (l < r) then
   2            m = (l + r) / 2;
   3            mergeSort(A, l, m);
   4            mergeSort(A, m + 1, r);
   5            merge(A, l, m, r)
</pre>
    </body>
</html>