/*
* This is file generated by vizi (http://neerc.ifmo.ru/vizi)
*/

package ru.ifmo.vizi.min_cost_max_flow;

import ru.ifmo.vizi.base.auto.*;
import java.util.Locale;

public final class MinCostMaxFlowDebug  {
    /**
      * пїЅпїЅпїЅпїЅпїЅпїЅ пїЅпїЅпїЅпїЅпїЅпїЅ.
      */
    public final Data d = new Data();

    /**
      * пїЅпїЅпїЅпїЅ.
      */
    public final AutoStack stack = new AutoStack();

    /**
      * пїЅпїЅпїЅпїЅпїЅпїЅ.
      */
    public final class Data {
        /**
          * Количество вершин.
          */
        public int n = 6;

        /**
          * Количество ребер.
          */
        public int m = 10;

        /**
          * Источник.
          */
        public int source = 0;

        /**
          * Сток.
          */
        public int sink = 1;

        /**
          * Матрица смежности графа.
          */
        public Edge[][] edge = new Edge[n][n];

        /**
          * Матрица смежности для обратных ребер графа.
          */
        public Edge[][] reverseEdge = new Edge[n][n];

        /**
          * Массив потенциалов.
          */
        public long[] phi = new long[n];

        /**
          * Расстояния от источника.
          */
        public long[] dist = new long[n];

        /**
          * Использовали ли мы данную вершину.
          */
        public boolean[] used = new boolean[n];

        /**
          * Массив для востановления кратчайшего пути.
          */
        public Edge[] prev = new Edge[n];

        /**
          * Текущяя стоимость потока.
          */
        public long cost = 0;

        /**
          * Максимальный дополняющий поток.
          */
        public long maxFlow = 0;

        /**
          * Надо ли отображать обратные ребра и дополнительную информацию в вершинах.
          */
        public boolean extendedDraw = false;

        /**
          * Что выделять (0 - ничего, 1 - расстояния, 2 - потенциалы).
          */
        public int highlight = 0;

        /**
          * Экзэмпляр апплета.
          */
        public MinCostMaxFlowVisualizer visualizer = null;

        /**
          * Переменная для использования в цикле (пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ dijkstra).
          */
        public int dijkstra_i;

        /**
          * Переменная для использования в цикле (пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ dijkstra).
          */
        public int dijkstra_j;

        /**
          * Текущая вершина в дейкстре (пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ dijkstra).
          */
        public int dijkstra_u;

        /**
          * Текущая вершина в предыдущем пути (пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ dijkstra).
          */
        public int dijkstra_cur;

        /**
          * переменная цикла (пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ updatePotentials).
          */
        public int updatePotentials_i;

        /**
          * Текущая вершина (пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ recoverPath).
          */
        public int recoverPath_cur;

        /**
          * текущая вершина (пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ letPassFlow).
          */
        public int letPassFlow_cur;

        /**
          * стоимость дополняющего потока (пїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅпїЅ letPassFlow).
          */
        public long letPassFlow_curCost;

        public String toString() {
            return "";
        }
    }

    /**
      * Вычисляет расстояния от источника до вершин.
      */
    private final void dijkstra() {
        // инициализируем cur 
        d.dijkstra_cur = d.sink;
        // убираем выделение с пути
        while ((d.prev[d.dijkstra_cur] != null) && (d.dijkstra_cur != d.source)) {
            // убираем выделение с текущего ребра 
            d.prev[d.dijkstra_cur].highlighted = false;
            d.dijkstra_cur = d.prev[d.dijkstra_cur].u;
        }
        // обнуляем i 
        d.dijkstra_i = 0;
        // Заполняет расстояния бесконечностями
        while (d.dijkstra_i < d.n) {
            // шаг цикла 
            d.dist[d.dijkstra_i] = -1;
            d.dijkstra_i = d.dijkstra_i + 1;
        }
        // обнуляем i2 
        d.dijkstra_i = 0;
        // Еще ничего не использовали
        while (d.dijkstra_i < d.n) {
            // шаг цикла 
            d.used[d.dijkstra_i] = false;
            d.dijkstra_i = d.dijkstra_i + 1;
        }
        // Делаем источник источником для Дейкстры и инициализируем i 
        d.dijkstra_i = 0;
        d.dist[d.source] = 0;d.prev[d.source] = null;
        // Внешний цикл дейкстры
        while (d.dijkstra_i < d.n) {
            // инициализируем u и j 
            d.dijkstra_u = -1;
            d.dijkstra_j = 0;
            // выбираем виршину
            while (d.dijkstra_j < d.n) {
                // выбираем наиболее близкую неиспользованную вершину
                if ((!d.used[d.dijkstra_j]) && (d.dist[d.dijkstra_j] >= 0) && ( ( d.dijkstra_u == -1) || ( d.dist[d.dijkstra_j] < d.dist[d.dijkstra_u] ) )) {
                    // обновляем u 
                    d.dijkstra_u = d.dijkstra_j;
                }
                // инкремент 
                d.dijkstra_j = d.dijkstra_j + 1;
            }
            // Есть ли вершина, которую можно использовать
            if (d.dijkstra_u != -1) {
                // инициализируем j 
                d.dijkstra_j = 0;
                // цикл по ребрам, инцидентным u
                while (d.dijkstra_j < d.n) {
                    // надо ли обновлять вершину на конце ребра
                    if ((d.edge[d.dijkstra_u][d.dijkstra_j] != null ) && ( d.edge[d.dijkstra_u][d.dijkstra_j].capacity - d.edge[d.dijkstra_u][d.dijkstra_j].flow > 0 ) && ( (d.dist[d.dijkstra_j] == -1 ) || (d.dist[d.dijkstra_u] + d.edge[d.dijkstra_u][d.dijkstra_j].cost - d.phi[d.dijkstra_j] + d.phi[d.dijkstra_u] < d.dist[d.dijkstra_j] ) )) {
                        // обновляем расстояние до вершины и добавляем ребро в массив для восстановления 
                        d.dist[d.dijkstra_j] = d.dist[d.dijkstra_u] + d.edge[d.dijkstra_u][d.dijkstra_j].cost - d.phi[d.dijkstra_j] + d.phi[d.dijkstra_u];
                        d.prev[d.dijkstra_j] = d.edge[d.dijkstra_u][d.dijkstra_j];
                    }
                    // следующее ребро 
                    d.dijkstra_j = d.dijkstra_j + 1;
                }
                // инициализируем j 
                d.dijkstra_j = 0;
                // цикл по обратным ребрам, инцидентным u
                while (d.dijkstra_j < d.n) {
                    // надо ли обновлять вершину на конце ребра
                    if ((d.reverseEdge[d.dijkstra_u][d.dijkstra_j] != null ) && ( d.reverseEdge[d.dijkstra_u][d.dijkstra_j].capacity - d.reverseEdge[d.dijkstra_u][d.dijkstra_j].flow > 0 ) && ( (d.dist[d.dijkstra_j] == -1 ) || (d.dist[d.dijkstra_u] + d.reverseEdge[d.dijkstra_u][d.dijkstra_j].cost - d.phi[d.dijkstra_j] + d.phi[d.dijkstra_u] < d.dist[d.dijkstra_j] ) )) {
                        // обновляем расстояние до вершины и добавляем ребро в массив для восстановления 
                        d.dist[d.dijkstra_j] = d.dist[d.dijkstra_u] + d.reverseEdge[d.dijkstra_u][d.dijkstra_j].cost - d.phi[d.dijkstra_j] + d.phi[d.dijkstra_u];
                        d.prev[d.dijkstra_j] = d.reverseEdge[d.dijkstra_u][d.dijkstra_j];
                    }
                    // следующее ребро 
                    d.dijkstra_j = d.dijkstra_j + 1;
                }
                // мы использовали вершину u 
                d.used[d.dijkstra_u] = true;
            }
            // инкремент 
            d.dijkstra_i = d.dijkstra_i + 1;
        }
    }

    /**
      * Обновление потенциалов.
      */
    private final void updatePotentials() {
        // инициализируем i 
        d.updatePotentials_i = 0;
        // цикл для обновления потенциалов
        while (d.updatePotentials_i < d.n) {
            // обновляем потенциал и переходим к следующей вершине 
            d.phi[d.updatePotentials_i] = d.dist[d.updatePotentials_i];
            d.updatePotentials_i = d.updatePotentials_i + 1;
        }
        // потенциалы обновлены 
        d.highlight = 2;
    }

    /**
      * Находим максимальный дополняющий поток для кратчайшего пути.
      */
    private final void recoverPath() {
        // инициализируем текущую вершину стоком и максимальный дополняющий поток последним ребром 
        d.recoverPath_cur = d.sink;
        d.maxFlow = d.prev[d.recoverPath_cur].capacity - d.prev[d.recoverPath_cur].flow;
        // находим максимальный дополняющий поток
        while (d.recoverPath_cur != d.source) {
            // выделяем ребро пути 
            d.prev[d.recoverPath_cur].highlighted = true;
            // надо ли обновлять поток
            if (d.maxFlow > d.prev[d.recoverPath_cur].capacity - d.prev[d.recoverPath_cur].flow) {
                // обновляем поток 
                d.maxFlow = d.prev[d.recoverPath_cur].capacity - d.prev[d.recoverPath_cur].flow;
            }
            // переходим к предыдущей вершине в пути 
            d.recoverPath_cur = d.prev[d.recoverPath_cur].u;
        }
        // путь восстановлен 
        d.highlight = 0;
    }

    /**
      * пропускаем поток и обновляем стоимость.
      */
    private final void letPassFlow() {
        // инициализируем начальную вершину стоком и текущую стоимость нулем 
        d.letPassFlow_cur = d.sink;
        d.letPassFlow_curCost = 0;
        // цикл для обновления потока и стоимости
        while (d.letPassFlow_cur != d.source) {
            // обратное ли это ребро
            if (d.prev[d.letPassFlow_cur].reversed) {
                // обновляем ребро, обратное текущему 
                d.edge[d.letPassFlow_cur][d.prev[d.letPassFlow_cur].u].flow = d.edge[d.letPassFlow_cur][d.prev[d.letPassFlow_cur].u].flow - d.maxFlow; 
            } else {
                // обновляем ребро, обратное текущему 
                d.reverseEdge[d.letPassFlow_cur][d.prev[d.letPassFlow_cur].u].flow = d.reverseEdge[d.letPassFlow_cur][d.prev[d.letPassFlow_cur].u].flow - d.maxFlow; 
            }
            // обновляем поток и стоимость 
            d.prev[d.letPassFlow_cur].flow = d.prev[d.letPassFlow_cur].flow + d.maxFlow;
            d.cost = d.cost + d.maxFlow * d.prev[d.letPassFlow_cur].cost;
            d.letPassFlow_curCost = d.letPassFlow_curCost + d.maxFlow * d.prev[d.letPassFlow_cur].cost;
            d.letPassFlow_cur = d.prev[d.letPassFlow_cur].u;
        }
        // пропустили поток 
    }

    /**
      * Находит максимальный поток минимальной стоимости.
      */
    private final void Main() {
        // Инициализация 
        d.extendedDraw = true;
        dijkstra(); 
        // Главный цикл
        while (d.dist[d.sink] != -1) {
            // существет путь 
            d.highlight = 1;
            updatePotentials(); 
            recoverPath(); 
            letPassFlow(); 
            dijkstra(); 
        }
        // путь до стока отсутствует 
        d.highlight = 1;
        // убираем расширенное рисование 
        d.extendedDraw = false;
    }
}
