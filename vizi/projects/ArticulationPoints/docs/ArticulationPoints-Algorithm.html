<html>
    <head>
        <title>
            Поиск точек сочленения и мостов.
        </title>
		<META http-equiv=Content-Type content="text/html; charset=windows-1251">
        <style type = "text/css">
            font.stn {
                font-family: "Times New Roman Cyr", "Times New Roman", "Times New", serif; 
                background-color: transparent; 
            }
            font.symbol {
                font-family: "Symbol"; 
                font-size: 10pt;
                background-color: transparent; 
            }
            font.code {
                font-family: "Lucida Console"; 
                font-size: 11pt;
                background-color: transparent; 
            }
        </style>
    </head>
    <body>
	  <B><center>Поиск точек сочленения.</center></B>
	  <p> Опишем простой алгоритм нахождения всех точек сочленения связного графа, основанный на методе
		  поиска в глубину.
	  </p>
	  <p>
		  1. Выполняется обход графа методом поиска в глубину, при этом для всех вершин v вычисляются числа
		     dfnum[v] равные номерам вершин при обходе в глубину. В сущности, эти числа фиксируют последовательность
			 обхода вершин в прямом порядке вершин глубинного остовного дерева. 
	  </p>
	  <p>
		  2. Для каждой вершины v вычисляется число low[v], равное минимуму чисел dfnum потомков вершины v, включая
			 и саму вершину v, и предков w вершины v, для которых существует обратное ребро (x, w), где x - потомок 
			 вершины v. Числа low[w] для всех вершин v вычисляются при обходе остовного дерева в обратном порядке,
			 поэтому при вычислении low[v] для вершины v уже подсчитаны числа low[x] для всех потомков x вершины v.
			 Следовательно, low[v] вычисляется как минимум следующих чисел:
	  </p>	
	  <p>
		  a) dfnum[v]
	  </p>
       <p>
		  b) dfnum[z], для всех вершин z, для которых существует обратное ребро (v, z)
	  </p>
	  <p>
		  c) low[x] всех потомков x вершины v
	  </p>

	  <p>
		  3. Теперь точки сочленения определяются следующим образом:
	  </p>
	  <p>
		  a) корень остовного дерева будет точкой сочленения тогда и только тогда, когда он имеет двух или более
сыновей. Так как в остовном дереве, которое получается методом поиска вглубь, нет поперечных ребер, то удаление
такого корня расчленит остовное дерево на отдельные поддеревья с корнями, яляющимися сыновьями корня построенного
остовного дерева.    
	  </p>
       <p>
		  b) вершина v, отличная от корня, будет точкой сочленения тогда и только тогда, когда имеет такого сына w,
что low[w] &gt;= dfnum[v]. В этом случае удаление вершины v (и, конечно, всех инцидентных ей ребер) отделит вершину
w и всех ее потомков от остальной части графа. Если же low[w] &lt; dfnum[v], то существует путь по ребрам дерева к 
потомкам вершины w и обратное ребро от какого-нибудь из этих потомков к истинному предку вершины v (именно значение
dfnum для этого предка равно low[w]). Поэтому в данном случае удаление вершины v не отделит от графа поддерево с 
корнем w.
	  </p>

	  <B><center>Поиск мостов.</center></B>
	  <p> Рассмотрим ребро (u, v). Пусть вершина u была раньше при обходе в глубину, чем вершина v.
		  Если low[u] равно low[v], то вершины  u и v принадлежат одному простому циклу, а, значит, 
		  ребро (u, v) - не мост. Если low[u] не равно low[v], то тогда дополнительно рассмотрим номера 
		  вершин при обходе в глубину (т.е. dfnum[u] и dfnum[v]). Если low вершины равно ее номеру при обходе 
		  (т.е. dfnum[u] = low[u]), то тогда либо она была первая в цикле при обходе в глубину, либо она не 
		  принадлежит ни одному циклу. Если она не принадлежит ни одному из циклов, то тогда ребро (u, v) -
		  мост. Осталось рассмотреть случай, когда обе эти вершины являются первыми в циклах при обходе. Пусть 
		  это так, тогда цикл вершины u, соединен c циклом вершины v ребром (u, v). Значит (u, v) - мост. 
		  В остальных случаях ребро (u, v) не является мостом.
		  
	</p>
    </body>
</html>