<html>
	<head>
    	<title>
			Дерево отрезков
        </title>
    </head>
    <body>
    	<font size=2>
        	<center>
                <h1>
                    Описание структуры данных - дерево отрезков
                </h1>
            </center>
            
            <h3>
            	1. Применение
            </h3>
        	<p>
        		Дерево отрезков - структура данных, предназначеная для обработки запросов типа Range Statistic Query.
                Эту структуру можно использовать для многократного поиска минимума среди элементов массива,
                заключенных в каком-либо отрезке, за время O(logN), где N - количество элементов.
                Процедура построения дерева занимает O(N) времени. Если для хранения дерева использовать массив,
                то потребуется O(N) дополнительной памяти. Помимо поиска минимума на заданном отрезке,
                рассматриваемую структуру данных можно использовать для поиска максимального элемента на отрезке,
                быстрого поиска суммы или произведения элементов в отрезке массива.
            </p>

            <p>
            	Еще одной важной отличительной особенностью дерева отрезков является то, что его очень просто реализовать на практике. 
            </p>

            <h3>
            	2. Построение дерева для операции "минимум среди чисел отрезка"
            </h3>
            <p>
            	Построение дерева отрезков за время O(N) можно осущесвить следующим способом:
                <ol>
                	<li> Достраиваем массив, до тех пор, пока его длина не станет равне степени двойки
                    <li> Сдвинем массив вправо на N-1 элемент, где N - количество элементов в достроеном массиве
                    <li> Вычисляем первые N элементов по правилу: a[i] = min(a[2 * i], a[2 * i + 1])
                </ol>
            </p>

            <h3>
                3. Поиск минимума на отрезке
            </h3>
            <p>
            	Поиск минимума осуществляется по следующему алгоритму:
            	<ol>
                    <li> Инициализируем минимум бесконечностью
                	<li> Устанавливаем границы поиска: l и r
                    <li> Сравниваем левый (a[l]) элемент в отрезке с текущим минимумом, если он меньше минимума, то производим обновление минимума
                    <li> Сравниваем правый (a[r]) элемент в отрезке с текущим минимумом, если он меньше минимума, то производим обновление минимума
                    <li> Поднимаем границы поиска по формулам: l=(l-1)/2 и r=(r+1)/2
                    <li> Пункты 4. и 5. повторяем пока левая граница не превысит правую
                    <li> Значение текущего минимума и будет искомым минимумом в отрезке 
                </ol>
            </p>

    	</font>
	</body>
</html>